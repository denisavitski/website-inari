---
export interface Props {
  class?: string
  markers?: boolean
  zones?: boolean
  user?: boolean
}

const { class: className, markers, zones, user, ...rest } = Astro.props
---

<e-map
  {...rest}
  class:list={['class', className]}
  data-popover-content
  {markers}
  {zones}
  {user}
>
</e-map>

<style is:global>
  e-map {
    position: relative;
    z-index: 1;
    display: block;
    color: black;
  }
</style>

<script>
  import { globalStore } from '@stores/globalStore'
  import { ticker } from 'aptechka/ticker'
  import { dispatchEvent } from 'aptechka/utils'

  export interface YMapEvents {
    markerClick: CustomEvent<{ address: string }>
    ready: CustomEvent
    userAddressChange: CustomEvent<{ address: string }>
    userAddressSearch: CustomEvent
  }

  let geojson: any

  export class YMapElement extends HTMLElement {
    #map: any = null
    #searchControl: any = null
    #zones: Array<any> = []
    #markers: Array<any> = []
    #markersActive = this.hasAttribute('markers')
    #zonesActive = this.hasAttribute('zones')
    #userSearchActive = this.hasAttribute('user')
    #allGeoObjects: any = null
    #pickupAddresses: Array<string> = []
    #userPlacemark: any = null
    #userAddress: string = ''
    #userCoords: any

    public get isReady() {
      return window.ymaps && this.#map
    }

    public get pickupAddresses() {
      return this.#pickupAddresses
    }

    public get userAddress() {
      return this.#userAddress
    }

    public getDistances() {
      if (this.isReady && this.#userSearchActive) {
        return this.#markers
          .map((marker) => {
            const address = marker.properties.get('iconCaption')

            if (typeof address === 'string') {
              let distance = 0

              if (this.#userCoords) {
                distance =
                  window.ymaps.coordSystem.geo.getDistance(
                    this.#userCoords,
                    marker.geometry.getCoordinates(),
                  ) / 1001
              }

              return { address, value: distance }
            }

            return null
          })
          .filter((v) => !!v)
      }

      return []
    }

    public async search(value: string): Promise<void> {
      if (value === this.#userAddress) {
        return
      }

      dispatchEvent(this, 'userAddressSearch', { custom: true })

      if (this.isReady) {
        if (value.length < 3) {
          this.#resetUserAddress()
          return
        }

        await this.#searchControl.search(value)

        const resultArray = this.#searchControl.getResultsArray()

        if (resultArray.length === 1) {
          this.#resetUserAddress()
          this.#createUserPlacemark(resultArray[0].geometry.getCoordinates())
        } else {
          this.#resetUserAddress()
        }
      }
    }

    public toggleMarkers(visible: boolean) {
      this.#markersActive = visible

      this.#markers.find((marker) => {
        marker.options.set({
          iconOpacity: visible ? 1 : 0,
          interactive: visible ? true : false,
          cursor: visible ? 'pointer' : 'default',
        })
      })
    }

    public toggleZones(visible: boolean) {
      this.#zonesActive = visible

      this.#zones.find((zone) => {
        zone.options.set({
          fillOpacity: this.#zonesActive ? zone.properties.get('fill-opacity') : 0,
          strokeOpacity: this.#zonesActive ? zone.properties.get('stroke-opacity') : 0,
          strokeWidth: this.#zonesActive ? zone.properties.get('stroke-width') : 0,
        })
      })
    }

    public pickMarker(address: string) {
      this.#markers.forEach((marker) => {
        if (marker.properties.get('iconCaption') === address) {
          marker.options.set({
            iconImageHref: '/images/geo-picked.svg',
          })

          this.#map.panTo(marker.geometry.getCoordinates())
        } else {
          marker.options.set({
            iconImageHref: '/images/geo.svg',
          })
        }
      })
    }

    public async findUserLocation() {
      if (this.isReady) {
        dispatchEvent(this, 'userAddressSearch', { custom: true })

        try {
          const userLocation = await window.ymaps.geolocation.get({
            provider: 'auto',
          })

          await this.#createUserPlacemark(userLocation.geoObjects.position)

          this.#map.panTo(userLocation.geoObjects.position)
        } catch (e) {
          console.error(e)
        }
      }
    }

    public getZone() {
      if (this.#userCoords) {
        const zones = this.#zones
          .filter((z) => z.geometry.contains(this.#userCoords))
          .map((v) => {
            return {
              zone: v.zone,
              description: v.description,
              addition: v.addition,
            }
          })

        return zones[zones.length - 1]
      }

      return null
    }

    public focusOnGeoObjects() {
      if (this.isReady && this.#allGeoObjects) {
        const bounds = this.#allGeoObjects.getBounds()

        this.#map.setBounds(bounds, {
          checkZoomRange: true,
          duration: 500,
        })
      }
    }

    protected connectedCallback() {
      ticker.subscribe(this.#scriptReadyListener)
    }

    protected disconnectedCallback() {
      this.innerHTML = ''
      this.#map?.destroy()
      ticker.unsubscribe(this.#scriptReadyListener)
    }

    async #createMap() {
      if (!geojson) {
        const geo = await fetch('/map.geojson')
        geojson = await geo.json()
      }

      if (!this.isConnected) {
        return
      }

      this.#map = new window.ymaps.Map(this, {
        center: [31.014281, 52.42416],
        zoom: 9,
        behaviors: ['default'],
        controls: [],
      })

      this.#map.events.add('sizechange', () => {
        this.focusOnGeoObjects()
      })

      if (this.#userSearchActive) {
        this.#map.events.add('click', async (e: any) => {
          this.#createUserPlacemark(e.get('coords'))
        })
      }

      this.#searchControl = new window.ymaps.control.SearchControl({
        options: {
          noPlacemark: true,
          provider: 'yandex#search',
        },
      })

      this.#allGeoObjects = window.ymaps
        .geoQuery(geojson)
        .addToMap(this.#map)
        .applyBoundsToMap(this.#map, {
          checkZoomRange: true,
        })

      this.#zones = []
      this.#markers = []

      await this.#allGeoObjects.each((obj: any) => {
        if (obj.geometry.getType() === 'Polygon') {
          this.#zones.push(obj)

          const [zoneName] = obj.properties.get('description')?.split('\n')

          const foundedZone = globalStore.delivery.findZone(zoneName)

          obj.zone = zoneName
          obj.description = foundedZone?.description
          obj.addition = foundedZone?.addition

          obj.options.set({
            fillColor: obj.properties.get('fill'),
            strokeColor: obj.properties.get('stroke'),
            strokeWidth: obj.properties.get('stroke-width'),
            strokeOpacity: this.#zonesActive ? obj.properties.get('stroke-opacity') : 0,
            fillOpacity: this.#zonesActive ? obj.properties.get('fill-opacity') : 0,
            interactive: false,
            cursor: 'default',
          })
        } else if (obj.geometry.getType() === 'Point') {
          const caption = obj.properties.get('iconCaption')

          if (caption) {
            this.#pickupAddresses.push(caption)
          }

          obj.options.set({
            iconLayout: 'default#image',
            iconImageHref: '/images/geo.svg',
            iconImageSize: [50, 50],
            iconImageOffset: [-25, -25],
            iconOpacity: this.#markersActive ? 1 : 0,
            interactive: false,
            cursor: this.#markersActive ? 'pointer' : 'default',
            hideIconOnBalloonOpen: false,
          })

          obj.events.add('click', (e: any) => {
            const target = e.get('target')
            const address = target.properties.get('iconCaption')
            this.pickMarker(address)
            dispatchEvent(this, 'markerClick', { detail: { address } })
          })

          this.#markers.push(obj)
        }
      })

      dispatchEvent(this, 'ready', { custom: true })
    }

    async #createUserPlacemark(coords: any) {
      dispatchEvent(this, 'userAddressSearch', { detail: { address: this.userAddress } })

      if (this.#userSearchActive) {
        if (this.#userPlacemark) {
          this.#userPlacemark.geometry.setCoordinates(coords)
        } else {
          this.#userPlacemark = new window.ymaps.Placemark(coords, {
            preset: 'islands#redDotIcon',
            hasBalloon: false,
          })

          this.#userPlacemark.options.set('draggable', true)

          this.#map.panTo(coords)

          this.#map.geoObjects.add(this.#userPlacemark)

          this.#userPlacemark.events.add('dragend', () => {
            this.#updateUserAddress(this.#userPlacemark.geometry.getCoordinates())
          })
        }

        await this.#updateUserAddress(coords)

        this.#userPlacemark?.options.set({ visible: true })
      }
    }

    #resetUserAddress() {
      this.#userAddress = ''
      this.#userCoords = null

      this.#userPlacemark?.options.set({ visible: false })

      dispatchEvent(this, 'userAddressChange', { detail: { address: this.#userAddress } })
    }

    async #updateUserAddress(coords: any) {
      this.#userAddress = await this.#getAddress(coords)
      this.#userCoords = this.#userPlacemark.geometry.getCoordinates()

      dispatchEvent(this, 'userAddressChange', { detail: { address: this.#userAddress } })
    }

    async #getAddress(coords: any) {
      const res = await window.ymaps.geocode(coords)

      const firstGeoObject = res.geoObjects.get(0)

      const addressLine = firstGeoObject.getAddressLine()

      // const caption = [
      //   firstGeoObject.getLocalities().length
      //     ? firstGeoObject.getLocalities()
      //     : firstGeoObject.getAdministrativeAreas(),
      //   firstGeoObject.getThoroughfare() || firstGeoObject.getPremise(),
      // ]
      //   .filter(Boolean)
      //   .join(', ')

      return addressLine
    }

    #scriptReadyListener = () => {
      if (window.ymaps) {
        window.ymaps.ready(() => {
          this.#createMap()
        })

        ticker.unsubscribe(this.#scriptReadyListener)
      }
    }
  }

  if (!customElements.get('e-map')) {
    customElements.define('e-map', YMapElement)
  }

  declare global {
    interface Window {
      ymaps: any
    }

    interface HTMLElementTagNameMap {
      'e-map': YMapElement
    }

    interface HTMLElementEventMap extends YMapEvents {}
  }
</script>
